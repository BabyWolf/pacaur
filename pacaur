#!/usr/bin/env bash
#
# pacaur: an AUR helper that minimizes user interaction
# Dependencies: makepkg (pacman), pacman, expac, auracle (auracle-git)
#

# gettext initialization
export LC_COLLATE=C
export TEXTDOMAIN='pacaur'
export TEXTDOMAINDIR='/usr/share/locale'

declare -r pacaur_version='4.8.6'
declare -r confdir='/etc'

LIBMAKEPKG="${LIBMAKEPKG:-/usr/share/makepkg}"

# Options
ASDEPS=0
ASEXPLICIT=0
AUR=0
CCOUNT=0
CHECKDEPS=0
COLOR=''
DCOUNT=0
DEVEL=0
DOWNLOADONLY=0
INFO=0
INSTALLPKG=0
NATIVE=0
NEEDED=0
NOCONFIRM=0
NODEPS=0
NOOP=0
OPERATION=''
PAC=0
REBUILD=0
REFRESH=0
REPO=0
SEARCH=0
UPGRADE=0
VER=0

export QUIET

PACMAN_ARGS=()
PACMAN_OPTS=()
MAKEPKG_OPTS+=()
AURACLE_OPTS=()

shopt -s extglob

# Import libmakepkg
for lib in parseopts util option error; do
    source "${LIBMAKEPKG}/util/${lib}.sh"
done
check_buildoption "check" "y" && CHECKDEPS=1

# determine config location
if [[ "${XDG_CONFIG_DIRS}" ]]; then
    for dir in ${XDG_CONFIG_DIRS//:/ }; do
        [[ -d "$dir/pacaur" ]] && export XDG_CONFIG_DIRS="$dir" && break
    done
fi
configdir="${XDG_CONFIG_DIRS:-"${confdir}/xdg"}/pacaur"
userconfigdir="${XDG_CONFIG_HOME:-"${HOME}/.config"}/pacaur"
userpacmandir="${XDG_CONFIG_HOME:-"${HOME}/.config"}/pacman"
usercachedir="${XDG_CACHE_HOME:-"${HOME}/.cache"}/pacaur"
tmpdir="${XDG_RUNTIME_DIR:-'/tmp'}"

# preserve environment variables
mapfile -td$'\n' restore_envvars < \
    <(declare -p PACMAN {PKG,SRC}{DEST,EXT} {SRCPKG,LOG}DEST BUILDDIR GPGKEY PACKAGER CARCH 2>/dev/null)

# source makepkg variables
if [[ -r "$MAKEPKG_CONF" ]]; then
    source "$MAKEPKG_CONF"
else
    source "$confdir/makepkg.conf"
    if [[ -r "$userpacmandir/makepkg.conf" ]]; then
        source "$userpacmandir/makepkg.conf"
    elif [[ -r "$HOME/.makepkg.conf" ]]; then
        source "$HOME/.makepkg.conf"
    fi
fi

# restore environment variables
for i in "${restore_envvars[@]}"; do
    : "$i"
done

# set default config variables
editor="${VISUAL:-"${EDITOR:-vi}"}"         # build files editor
displaybuildfiles=diff                      # display build files (none|diff|full)
silent=false                                # silence output
sortby=name                                 # sort method (name|votes|popularity)
sortorder=ascending                         # sort order (ascending|descending)
sudoloop=true                               # prevent sudo timeout

# set variables
PACMAN="${PACMAN:-pacman}"                  # pacman binary
clonedir="${AURDEST:-${usercachedir:?}}"    # clone directory

# source xdg config
[[ -r "$configdir/config" ]] && source "$configdir/config"
[[ -r "$userconfigdir/config" ]] && source "$userconfigdir/config"

# determine whether we have gettext; make it a no-op if we do not
type -p gettext &>/dev/null || gettext() { printf '%s\n' "$@"; }

# define vcs packages
declare -r vcs='-(cvs|svn|git|hg|bzr|darcs|daily.*|nightly.*)$'

# set variables to readonly and setup clonedir
declare -r clonedir configdir userconfigdir userpacmandir usercachedir tmpdir
mkdir -pm700 "$clonedir"

#
# Functions
#

ClassifyPkgs() {
    local noaurpkgs norepopkgs
    # global aurpkgs repopkgs
    (( REPO )) && repopkgs=("${pkgs[@]}")
    if (( AUR )); then
        for i in "${pkgs[@]}"; do
            [[ "$i" = aur/* ]] && aurpkgs+=("${i:4}") && continue # search aur/pkgs in AUR
            aurpkgs+=("$i")
        done
    fi
    if (( ! AUR && ! REPO )); then
        unset noaurpkgs
        for i in "${pkgs[@]}"; do
            [[ "$i" = aur/* ]] && aurpkgs+=("${i:4}") && continue # search aur/pkgs in AUR
            noaurpkgs+=("$i")
        done
        [[ "${noaurpkgs[*]}" ]] &&
            IFS=$'\n' mapfile -t < <(LC_ALL=C "$PACMAN" -Sp "${noaurpkgs[@]}" 2>&1 >/dev/null) norepopkgs &&
            norepopkgs=("${norepopkgs[@]#error: target not found: }")
        for i in "${norepopkgs[@]}"; do
            # do not search repo/pkgs in AUR
            [[ " ${noaurpkgs[*]} " =~ [a-zA-Z0-9\.\+-]+\/"$i"[^a-zA-Z0-9\.\+-] ]] || aurpkgs+=("$i")
        done
        repopkgs=($(CommArr 'aurpkgs' 'noaurpkgs' '-13'))
    fi
}

Core() {
    GetIgnoredPkgs
    GetIgnoredGrps
    (( UPGRADE )) && UpgradeAur
    IgnoreChecks
    DepsSolver
    IgnoreDepsChecks
    ProviderChecks
    ConflictChecks
    ReinstallChecks
    OutOfDateChecks
    OrphanChecks
    Prompt
    MakePkgs
}

UpgradeAur() {
    local foreignpkgs allaurpkgs aurforeignpkgs i
    # global aurpkgs
    Note "i" $"${WHITE}Starting AUR upgrade...${ALL_OFF}"
    foreignpkgs=($("$PACMAN" -Qmq))
    SetInfo "${foreignpkgs[@]}"
    allaurpkgs=($(GetInfo "Name"))

    # foreign packages check
    aurforeignpkgs=($(CommArr 'allaurpkgs' 'foreignpkgs' '-13'))
    for i in "${aurforeignpkgs[@]}"; do
        Note "w" $"${WHITE}$i${ALL_OFF} is ${YELLOW}not present${ALL_OFF} in AUR -- skipping"
    done

    # use auracle to find out of date AUR packages
    mapfile -t < <(auracle sync -q) aurpkgs

    # add devel packages
    if (( DEVEL )); then
        for i in "${allaurpkgs[@]}"; do
            [[ "$i" =~ $vcs && ! " ${aurpkgs[*]} " =~ " $i " ]] && aurpkgs+=("$i")
        done
    fi

    aurpkgs+=("${pkgs[@]}")

    # avoid possible duplicate
    aurpkgs=($(printf '%s\n' "${aurpkgs[@]}" | sort -u))

    NothingToDo "${aurpkgs[@]}"
}

IgnoreChecks() {
    local checkaurpkgs checkaurpkgsAver checkaurpkgsQver checkaurpkgsgrp i
    # global aurpkgs rmaurpkgs
    [[ "${ignoredpkgs[*]}" || "${ignoredgrps[*]}" ]] || return

    # remove AUR pkgs versioning
    aurpkgsnover=("${aurpkgs[@]%%[><=]*}")

    # check targets
    SetInfo "${aurpkgsnover[@]}"
    checkaurpkgs=($(GetInfo "Name"))
    errdeps=($(CommArr 'aurpkgsnover' 'checkaurpkgs' '-3'))
    unset aurpkgsnover

    checkaurpkgsAver=($(GetInfo "Version"))
    mapfile -t < <(expac -Qv '%v' "${checkaurpkgs[@]}" 2>&1) checkaurpkgsQver
    for i in "${!checkaurpkgs[@]}"; do
        [[ "${checkaurpkgs[$i]}" =~ $vcs ]] && checkaurpkgsAver[$i]=$"latest"
        unset isignored
        if [[ " ${ignoredpkgs[*]} " =~ " ${checkaurpkgs[$i]} " ]]; then
            isignored=1
        elif [[ "${ignoredgrps[*]}" ]]; then
            unset checkaurpkgsgrp
            checkaurpkgsgrp=($(GetInfo "Groups" "${checkaurpkgs[$i]}"))
            checkaurpkgsgrp+=($(expac -Q '%G' "${checkaurpkgs[$i]}"))
            for j in "${checkaurpkgsgrp[@]}"; do
                [[ " ${ignoredgrps[*]} " =~ " $j " ]] && isignored=1
            done
        fi

        if [[ "$isignored" ]] ; then
            if (( ! UPGRADE )); then
                if (( ! NOCONFIRM )); then
                    if ! Proceed "y" $"${checkaurpkgs[$i]} is in IgnorePkg/IgnoreGroup. Install anyway?"; then
                        Note "w" $"skipping target: ${WHITE}${checkaurpkgs[$i]}${ALL_OFF}"
                        rmaurpkgs+=("${checkaurpkgs[$i]}")
                        continue
                    fi
                else
                    Note "w" $"skipping target: ${WHITE}${checkaurpkgs[$i]}${ALL_OFF}"
                    rmaurpkgs+=("${checkaurpkgs[$i]}")
                    continue
                fi
            else
                Note "w" $"${WHITE}${checkaurpkgs[$i]}${ALL_OFF}: ignoring package upgrade (${RED}${checkaurpkgsQver[$i]}${ALL_OFF} => ${GREEN}${checkaurpkgsAver[$i]}${ALL_OFF})"
                rmaurpkgs+=("${checkaurpkgs[$i]}")
                continue
            fi
        fi
        aurpkgsnover+=("${checkaurpkgs[$i]}")
    done

    aurpkgs=("${aurpkgsnover[@]}")
    NothingToDo "${aurpkgs[@]}"
}

DepsSolver() {
    local i aurpkgsconflicts
    # global aurpkgs aurpkgsnover aurpkgsproviders aurdeps deps errdeps
    # global errdepsnover foreignpkgs repodeps depsAname depsAver depsAood depsQver
    Note "i" $"resolving dependencies..."

    # remove AUR pkgs versioning
    aurpkgsnover=("${aurpkgs[@]%%[><=]*}")

    # set unversioned info
    SetInfo "${aurpkgsnover[@]}"

    # set targets providers
    aurpkgsproviders=("${aurpkgsnover[@]}")
    aurpkgsproviders+=($(GetInfo "Provides"))
    aurpkgsproviders=("${aurpkgsproviders[@]%%[><=]*}")

    # check targets conflicts
    aurpkgsconflicts=($(GetInfo "Conflicts"))
    if [[ "${aurpkgsconflicts[*]}" ]]; then
        aurpkgsconflicts=("${aurpkgsconflicts[@]%%[><=]*}")
        aurpkgsconflicts=($(CommArr 'aurpkgsproviders' 'aurpkgsconflicts' '-12'))
        for i in "${aurpkgsconflicts[@]}"; do
            [[ " ${aurpkgsnover[*]} " =~ " $i " ]] || continue
            [[ " $(GetInfo "Conflicts" "$i") " =~ " $i " ]] && continue
            Note "f" $"unresolvable package conflicts detected"
            Note "e" $"failed to prepare transaction (conflicting dependencies: $i)" "$E_INSTALL_DEPS_FAILED"
        done
    fi

    deps=("${aurpkgsnover[@]}")

    [[ "${foreignpkgs[*]}" ]] || foreignpkgs=($("$PACMAN" -Qmq))
    FindDepsAur "${aurpkgsnover[@]}"

    # avoid possible duplicate
    deps=($(CommArr 'aurdepspkgs' 'deps' '-13'))
    deps+=("${aurdepspkgs[@]}")

    # ensure correct dependency order
    SetInfo "${deps[@]}"
    SortDepsAur "${aurpkgs[@]}"
    deps=($(tsort <<< "${tsortdeps[@]}")) || Note "e" $"dependency cycle detected" "$E_INSTALL_DEPS_FAILED"

    # get AUR packages info
    depsAname=($(GetInfo "Name"))
    depsAver=($(GetInfo "Version"))
    depsAood=($(GetInfo "OutOfDate"))
    depsAmain=($(GetInfo "Maintainer"))
    for i in "${!depsAname[@]}"; do
        read -rd' ' < <(expac -Qs '%v' "^${depsAname[$i]}$") depsQver[$i]
        [[ "${depsQver[$i]}" ]] || depsQver[$i]="%"  # avoid empty elements shift
        [[ "${depsAname[$i]}" =~ $vcs ]] && depsAver[$i]=$"latest"
    done

    # no results check
    if [[ "${errdeps[*]}" ]]; then
        for i in "${!errdepsnover[@]}"; do
            if [[ " ${aurpkgsnover[*]} " =~ " ${errdepsnover[$i]} " ]]; then
                Note "f" $"no results found for ${errdeps[$i]}"
            else
                unset tsorterrdeps errdepslist currenterrdep
                # find relevant tsorted deps chain
                for j in "${deps[@]}"; do
                    tsorterrdeps+=("$j")
                    [[ "$j" = "${errdepsnover[$i]}" ]] && break
                done
                # reverse deps order
                for j in "${!tsorterrdeps[@]}"; do
                    tsorterrdepsrev[$j]="${tsorterrdeps[-j-1]}"
                done
                tsorterrdeps=("${tsorterrdepsrev[@]}") && unset tsorterrdepsrev
                errdepslist+=("${tsorterrdeps[0]}")
                FindDepsAurError "${tsorterrdeps[@]}"
                for j in "${!errdepslist[@]}"; do
                    [[ "${errdepslist[-j-1]}" ]] && errdepslistrev+=("${errdepslist[-j-1]}")
                done
                errdepslist=("${errdepslistrev[@]}") && unset errdepslistrev
                Note "f" $"no results found for ${errdeps[$i]} (dependency tree: ${errdepslist[*]})"
            fi
        done
        exit "$E_INSTALL_DEPS_FAILED"
    fi

    # return all binary deps
    FindDepsRepo "${repodeps[@]}"

    # avoid possible duplicate
    repodepspkgs=($(printf '%s\n' "${repodepspkgs[@]}" | sort -u))
}

FindDepsAur() {
    local depspkgs depspkgstmp depspkgsaurtmp builtpkg vcsdepspkgs assumedepspkgs aurversionpkgs
    local aurversionpkgsname aurversionpkgsver aurversionpkgsaurver aurversionpkgsverdiff i j
    # global aurpkgsnover depspkgsaur errdeps repodeps aurdepspkgs prevdepspkgsaur foreignpkgs
    (( NODEPS && DCOUNT >= 2 )) && return

    # set info
    unset aurversionpkgs
    if [[ "${depspkgsaur[*]}" ]]; then
        SetInfo "${depspkgsaur[@]}"
        aurversionpkgs=("${prevdepspkgsaur[@]}")
    else
        SetInfo "${aurpkgsnover[@]}"
        aurversionpkgs=("${aurpkgs[@]}")
    fi

    # versioning check
    if [[ "${aurversionpkgs[*]}" ]]; then
        for i in "${!aurversionpkgs[@]}"; do
            unset aurversionpkgsname aurversionpkgsver aurversionpkgsaurver aurversionpkgsverdiff
            aurversionpkgsname="${aurversionpkgs[$i]%%[><=]*}"
            aurversionpkgsver="${aurversionpkgs[$i]##*[><=]}"
            aurversionpkgsaurver="$(GetInfo "Version" "$aurversionpkgsname")"
            aurversionpkgsverdiff="$(vercmp "$aurversionpkgsaurver" "$aurversionpkgsver")"

            # not found in AUR nor repo
            [[ ! "$aurversionpkgsaurver" && ! " ${errdeps[*]} " =~ " ${aurversionpkgs[$i]} " ]] &&
                errdeps+=("${aurversionpkgs[$i]}") && continue

            case "${aurversionpkgs[$i]}" in
                *">"*|*"<"*|*"="*)
                    # found in AUR but version not correct
                    case "${aurversionpkgs[$i]}" in
                        *">="*) [[ "$aurversionpkgsverdiff" -ge 0 ]] && continue;;
                        *"<="*) [[ "$aurversionpkgsverdiff" -le 0 ]] && continue;;
                        *">"*)  [[ "$aurversionpkgsverdiff" -gt 0 ]] && continue;;
                        *"<"*)  [[ "$aurversionpkgsverdiff" -lt 0 ]] && continue;;
                        *"="*)  [[ "$aurversionpkgsverdiff" -eq 0 ]] && continue;;
                    esac
                    [[ " ${errdeps[*]} " =~ " ${aurversionpkgs[$i]} " ]] ||
                        errdeps+=("${aurversionpkgs[$i]}");;
                *) continue;;
            esac
        done
    fi

    depspkgs=($(GetInfo "Depends"))

    # cached packages makedeps check
    if [[ ! "$PKGDEST" ]] || (( REBUILD )); then
        depspkgs+=($(GetInfo "MakeDepends"))
        (( CHECKDEPS )) && depspkgs+=($(GetInfo "CheckDepends"))
    else
        [[ ! "${depspkgsaur[*]}" ]] && depspkgsaurtmp=("${aurpkgs[@]}") ||
            depspkgsaurtmp=("${depspkgsaur[@]}")
        for i in "${!depspkgsaurtmp[@]}"; do
            local depAname="$(GetInfo "Name" "${depspkgsaurtmp[$i]}")"
            local depAver="$(GetInfo "Version" "${depspkgsaurtmp[$i]}")"
            GetBuiltPkg "$depAname-$depAver" "$PKGDEST"
            if [[ ! "$builtpkg" ]]; then
                depspkgs+=($(GetInfo "MakeDepends" "${depspkgsaurtmp[$i]}"))
                (( CHECKDEPS )) && depspkgs+=($(GetInfo "CheckDepends"))
            fi
            unset builtpkg
        done
    fi

    # remove deps provided by targets
    [[ "${aurpkgsproviders[*]}" ]] && depspkgs=($(CommArr 'aurpkgsproviders' 'depspkgs' '-13'))

    # workaround for limited RPC support of architecture dependent fields
    if [[ "${CARCH}" = 'i686' ]]; then
        for i in "${!depspkgs[@]}"; do
            [[ "${depspkgs[$i]}" =~ ^(lib32-|gcc-multilib) ]] && unset depspkgs[$i]
        done
        depspkgs=($(printf '%s\n' "${depspkgs[@]}"))
    fi

    # remove versioning
    depspkgs=("${depspkgs[@]%%[><=]*}")
    # remove installed deps
    if (( ! DEVEL )); then
        depspkgs=($("$PACMAN" -T -- "${depspkgs[@]}" | sort -u))
    else
        # check providers
        unset vcsdepspkgs
        for i in "${!depspkgs[@]}"; do
            unset j && read -rd' ' < <(expac -Qs '%n %P' "^${depspkgs[$i]}$") j
            if [[ "$j" ]]; then
                depspkgs[$i]="$j"
                (( DEVEL )) && [[ ! " ${ignoredpkgs[*]} " =~ " $j " && "$j" =~ $vcs ]] &&
                    vcsdepspkgs+=("$j")
            else
                foreignpkgs+=("${depspkgs[$i]}")
            fi
        done
        # reorder devel
        depspkgs=($("$PACMAN" -T -- "${depspkgs[@]}" | sort -u))
        depspkgs=($(CommArr 'depspkgs' 'vcsdepspkgs' '-3'))
    fi

    # split repo and AUR depends pkgs
    unset depspkgsaur
    if [[ "${depspkgs[*]}" ]]; then
        # remove all pkgs versioning
        if (( NODEPS && DCOUNT == 1 )); then
            depspkgs=("${depspkgs[@]%%[><=]*}")
        # assume installed deps
        elif [[ "${assumeinstalled[*]}" ]]; then
            # remove versioning
            assumeinstalled=("${assumeinstalled[@]%%[><=]*}")
            for i in "${!assumeinstalled[@]}"; do
                unset assumedepspkgs
                for j in "${!depspkgs[@]}"; do
                    assumedepspkgs[$j]="${depspkgs[$j]%%[><=]*}"
                    [[ " ${assumedepspkgs[*]} " =~ " ${assumeinstalled[$i]} " ]] &&
                        depspkgs[$j]="${assumeinstalled[$i]}";
                done
            done
            depspkgs=($(CommArr 'assumeinstalled' 'depspkgs' '-13'))
        fi
        if [[ "${depspkgs[*]}" ]]; then
            IFS=$'\n' mapfile -t < <(LC_ALL=C "$PACMAN" -Sp "${depspkgs[@]}" 2>&1 >/dev/null ) depspkgsaur &&
            depspkgsaur=("${depspkgsaur[@]#error: target not found: }")
            repodeps+=($(CommArr 'depspkgsaur' 'depspkgs' '-13'))
        fi
    fi
    unset depspkgs

    # remove duplicate
    [[ "${depspkgsaur[*]}" ]] && depspkgsaur=($(CommArr 'aurdepspkgs' 'depspkgsaur' '-13'))

    # dependency cycle check
    [[ "${prevdepspkgsaur[*]}" ]] && [[ "${prevdepspkgsaur[*]}" = "${depspkgsaur[*]}" ]] &&
        Note "e" $"dependency cycle detected (${depspkgsaur[*]})" "$E_INSTALL_DEPS_FAILED"

    if [[ "${depspkgsaur[*]}" ]]; then
        # store for AUR version check
        (( NODEPS )) || prevdepspkgsaur=("${depspkgsaur[@]}")
        # remove duplicates and versioning
        depspkgsaur=($(printf '%s\n' "${depspkgsaur[@]%%[><=]*}" | sort -u))
    fi

    [[ "${depspkgsaur[*]}" ]] && aurdepspkgs+=("${depspkgsaur[@]}") &&
        FindDepsAur "${depspkgsaur[@]}"
}

SortDepsAur() {
    local i j sortaurpkgs sortdepspkgs sortdepspkgsaur
    # global checkedsortdepspkgsaur allcheckedsortdepspkgsaur errdepsnover
    [[ "${checkedsortdepspkgsaur[*]}" ]] && sortaurpkgs=("${checkedsortdepspkgsaur[@]}") ||
        sortaurpkgs=("${aurpkgs[@]}")

    unset checkedsortdepspkgsaur
    for i in "${!sortaurpkgs[@]}"; do
        unset sortdepspkgs sortdepspkgsaur

        sortdepspkgs+=($(GetInfo "Depends" "${sortaurpkgs[$i]}"))
        sortdepspkgs+=($(GetInfo "MakeDepends" "${sortaurpkgs[$i]}"))
        (( CHECKDEPS )) && sortdepspkgs+=($(GetInfo "CheckDepends"))

        # remove versioning
        errdepsnover=("${errdeps[@]%%[><=]*}")

        # check AUR deps only
        for j in "${!sortdepspkgs[@]}"; do
            sortdepspkgs[$j]="${sortdepspkgs[$j]%%[><=]*}"
            sortdepspkgsaur+=($(GetInfo "Name" "${sortdepspkgs[$j]}"))
            # add erroneous AUR deps
            [[ " ${errdepsnover[*]} " =~ " ${sortdepspkgs[$j]} " ]] &&
                sortdepspkgsaur+=("${sortdepspkgs[$j]}")
        done

        # prepare tsort list
        if [[ ! "${sortdepspkgsaur[*]}" ]]; then
            tsortdeps+=("${sortaurpkgs[$i]} ${sortaurpkgs[$i]}")
        else
            for j in "${!sortdepspkgsaur[@]}"; do
                tsortdeps+=("${sortaurpkgs[$i]} ${sortdepspkgsaur[$j]}")
            done
        fi

        # filter non checked deps
        sortdepspkgsaur=($(CommArr 'allcheckedsortdepspkgsaur' 'sortdepspkgsaur' '-13'))
        if [[ "${sortdepspkgsaur[*]}" ]]; then
            checkedsortdepspkgsaur+=("${sortdepspkgsaur[@]}")
            allcheckedsortdepspkgsaur+=("${sortdepspkgsaur[@]}")
            allcheckedsortdepspkgsaur=($(printf '%s\n' "${allcheckedsortdepspkgsaur[@]}" | sort -u))
        fi
    done
    if [[ "${checkedsortdepspkgsaur[*]}" ]]; then
        checkedsortdepspkgsaur=($(printf '%s\n' "${checkedsortdepspkgsaur[@]}" | sort -u))
        SortDepsAur "${checkedsortdepspkgsaur[@]}"
    fi
}

FindDepsAurError() {
    local i nexterrdep nextallerrdeps
    # global errdepsnover errdepslist tsorterrdeps currenterrdep

    for i in "${tsorterrdeps[@]}"; do
        [[ " ${errdepsnover[*]} " =~ " $i " || " ${errdepslist[*]} " =~ " $i " ]] || nexterrdep="$i" && break
    done

    [[ "${currenterrdep[*]}" ]] || currenterrdep="${tsorterrdeps[0]}"
    if [[ ! " ${aurpkgs[*]} " =~ " $nexterrdep " ]]; then
        nextallerrdeps=($(GetInfo "Depends" "$nexterrdep"))
        nextallerrdeps+=($(GetInfo "MakeDepends" "$nexterrdep"))
        (( CHECKDEPS )) && nextallerrdeps+=($(GetInfo "CheckDepends"))

        # remove versioning
        nextallerrdeps=("${nextallerrdeps[@]%%[><=]*}")

        [[ " ${nextallerrdeps[*]} " =~ " $currenterrdep " ]] && errdepslist+=("$nexterrdep") &&
            currenterrdep="${tsorterrdeps[0]}"
        tsorterrdeps=("${tsorterrdeps[@]:1}")
        FindDepsAurError "${tsorterrdeps[@]}"
    else
        for i in "${!aurpkgs[@]}"; do
            nextallerrdeps=($(GetInfo "Depends" "${aurpkgs[$i]}"))
            nextallerrdeps+=($(GetInfo "MakeDepends" "${aurpkgs[$i]}"))
            (( CHECKDEPS )) && nextallerrdeps+=($(GetInfo "CheckDepends"))

            # remove versioning
            nextallerrdeps=("${nextallerrdeps[@]%%[><=]*}")

            [[ " ${nextallerrdeps[*]} " =~ " $currenterrdep " ]] && errdepslist+=("${aurpkgs[$i]}")
        done
    fi
}

FindDepsRepo() {
    local allrepodepspkgs repodepspkgstmp
    # global repodeps repodepspkgs
    [[ "${repodeps[*]}" ]] || return

    # reduce root binary deps
    repodeps=($(printf '%s\n' "${repodeps[@]}" | sort -u))

    # add initial repodeps
    [[ "${repodepspkgs[*]}" ]] || repodepspkgs=("${repodeps[@]}")

    # get non installed binary deps
    unset allrepodepspkgs repodepspkgstmp
    # no version check needed as all deps are repo deps
    [[ "${repodeps[*]}" ]] && allrepodepspkgs=($(expac -S1 '%E' "${repodeps[@]}"))
    [[ "${allrepodepspkgs[*]}" ]] && repodepspkgstmp=($("$PACMAN" -T -- "${allrepodepspkgs[@]}" | sort -u))

    # remove duplicate
    [[ "${repodepspkgstmp[*]}" ]] && repodepspkgstmp=($(CommArr 'repodepspkgs' 'repodepspkgstmp' '-13'))
    [[ "${repodepspkgstmp[*]}" ]] && repodepspkgs+=("${repodepspkgstmp[@]}") &&
        repodeps=("${repodepspkgstmp[@]}") && FindDepsRepo "${repodeps[@]}"
}

FindDepsRepoProvider() {
    local allrepodepspkgs providerrepodepspkgstmp
    # global repodeps repodepspkgs
    [[ "${providerspkgs[*]}" ]] || return

    # reduce root binary deps
    providerspkgs=($(printf '%s\n' "${providerspkgs[@]}" | sort -u))

    # get non installed repo deps
    unset allproviderrepodepspkgs providerrepodepspkgstmp
    [[ "${providerspkgs[*]}" ]] && allproviderrepodepspkgs=($(expac -S1 '%E' "${providerspkgs[@]}"))
    # no version check needed as all deps are binary
    [[ "${allproviderrepodepspkgs[*]}" ]] &&
        providerrepodepspkgstmp=($("$PACMAN" -T -- "${allproviderrepodepspkgs[@]}" | sort -u))

    # remove duplicate
    [[ "${providerrepodepspkgstmp[*]}" ]] &&
        providerrepodepspkgstmp=($(CommArr 'repodepspkgs' 'providerrepodepspkgstmp' '-13'))

    [[ "${providerrepodepspkgstmp[*]}" ]] && repodepspkgs+=("${providerrepodepspkgstmp[@]}") &&
        providerspkgs=("${providerrepodepspkgstmp[@]}") && FindDepsRepoProvider "${providerspkgs[@]}"
}

IgnoreDepsChecks() {
    local i
    # global ignoredpkgs aurpkgs aurdepspkgs aurdepspkgsgrp repodepspkgsgrp rmaurpkgs deps repodepspkgs
    [[ "${ignoredpkgs[*]}" || "${ignoredgrps[*]}" ]] || return

    # add checked targets and preserve tsorted order
    deps=("${deps[@]:0:${#aurpkgs[@]}}")

    # check dependencies
    for i in "${repodepspkgs[@]}"; do
        unset isignored
        if [[ " ${ignoredpkgs[*]} " =~ " $i " ]]; then
            isignored=1
        elif [[ "${ignoredgrps[*]}" ]]; then
            unset repodepspkgsSgrp repodepspkgsQgrp
            repodepspkgsgrp=($(expac -S1 '%G' "$i"))
            repodepspkgsgrp+=($(expac -Q '%G' "$i"))
            for j in "${repodepspkgsgrp[@]}"; do
                [[ " ${ignoredgrps[*]} " =~ " $j " ]] && isignored=1
            done
        fi

        if [[ "$isignored" ]]; then
            (( ! UPGRADE )) && Note "w" $"skipping target: ${WHITE}$i${ALL_OFF}" ||
                Note "w" $"${WHITE}$i${ALL_OFF}: ignoring package upgrade"
            Note "e" $"Unresolved dependency '${WHITE}$i${ALL_OFF}'" "$E_INSTALL_DEPS_FAILED"
        fi
    done
    for i in "${aurdepspkgs[@]}"; do
        # skip already checked dependencies
        [[ " ${aurpkgs[*]} " =~ " $i " ]] && continue
        [[ " ${rmaurpkgs[*]} " =~ " $i " ]] &&
            Note "e" $"Unresolved dependency '${WHITE}$i${ALL_OFF}'" "$E_INSTALL_DEPS_FAILED"

        unset isignored
        if [[ " ${ignoredpkgs[*]} " =~ " $i " ]]; then
            isignored=1
        elif [[ "${ignoredgrps[*]}" ]]; then
            unset aurdepspkgsgrp
            aurdepspkgsgrp=($(GetInfo "Groups" "$i"))
            aurdepspkgsgrp+=($(expac -Q '%G' "$i"))
            for j in "${aurdepspkgsgrp[@]}"; do
                [[ " ${ignoredgrps[*]} " =~ " $j " ]] && isignored=1
            done
        fi

        if [[ "$isignored" ]]; then
            if (( ! NOCONFIRM )); then
                if ! Proceed "y" $"$i dependency is in IgnorePkg/IgnoreGroup. Install anyway?"; then
                    Note "w" $"skipping target: ${WHITE}$i${ALL_OFF}"
                    Note "e" $"Unresolved dependency '${WHITE}$i${ALL_OFF}'" "$E_INSTALL_DEPS_FAILED"
                fi
            else
                (( UPGRADE )) && Note "w" $"${WHITE}$i${ALL_OFF}: ignoring package upgrade" ||
                    Note "w" $"skipping target: ${WHITE}$i${ALL_OFF}"
                Note "e" $"Unresolved dependency '${WHITE}$i${ALL_OFF}'" "$E_INSTALL_DEPS_FAILED"
            fi
        fi
        deps+=("$i")
    done
}

ProviderChecks() {
    local providersdeps providersdepsnover providers repodepspkgsprovided providerspkgs provided
    local nb providersnb
    # global repodepspkgs repoprovidersconflictingpkgs repodepsSver repodepsSrepo repodepsQver
    [[ "${repodepspkgs[*]}" ]] || return

    # filter directly provided deps
    noprovidersdeps=($(expac -S1 '%n' "${repodepspkgs[@]}"))
    providersdeps=($(CommArr 'noprovidersdeps' 'repodepspkgs' '-13'))

    # remove installed providers
    providersdeps=($("$PACMAN" -T -- "${providersdeps[@]}" | sort -u))

    for i in "${!providersdeps[@]}"; do
        # check versioning
        unset providersdepsname providersdepsver providersdepsSname providersdepsSver
        providersdepsname="${providersdeps[$i]%%[><=]*}"
        providersdepsver="${providersdeps[$i]##*[><=]}"
        providersdepsSname=($(expac -Ss '%n' "^${providersdepsname[$i]}$"))
        providersdepsSver=($(expac -Ss '%v' "^${providersdepsname[$i]}$"))

        case "${providersdeps[$i]}" in
            *">"*|*"<"*|*"="*)
                for j in "${!providersdepsSname[@]}"; do
                    unset providersdepverdiff
                    providersdepsverdiff="$(vercmp "$providersdepsver" "${providersdepsSver[j]}")"
                    # found in repo but version not correct
                    case "${providersdeps[$i]}" in
                        *">="*) [[ "$providersdepsverdiff" -ge 0 ]] && continue;;
                        *"<="*) [[ "$providersdepsverdiff" -le 0 ]] && continue;;
                        *">"*)  [[ "$providersdepsverdiff" -gt 0 ]] && continue;;
                        *"<"*)  [[ "$providersdepsverdiff" -lt 0 ]] && continue;;
                        *"="*)  [[ "$providersdepsverdiff" -eq 0 ]] && continue;;
                    esac
                    providersdepsnover+=("${providersdepsSname[j]}")
                done
            ;;
        esac

        # remove versioning
        providersdeps[$i]="${providersdeps[$i]%%[><=]*}"

        # list providers
        providers=($(expac -Ss '%n' "^${providersdeps[$i]}$" | sort -u))

        # filter out non matching versioned providers
        [[ "${providersdepsnover[*]}" ]] && providers=($(CommArr 'providersdepsnover' 'providers' '-12'))

        # skip if provided in dependency chain
        unset repodepspkgsprovided
        for j in "${!providers[@]}"; do
            [[ " ${repodepspkgs[*]} " =~ " ${providers[$j]} " ]] && repodepspkgsprovided='true'
        done
        [[ "$repodepspkgsprovided" ]] && continue

        # skip if already provided
        if [[ "${providerspkgs[*]}" ]]; then
            providerspkgs=($(printf '%s|' "${providerspkgs[@]}"))
            providerspkgs=("${providerspkgs[@]%|}")
            provided+=($(expac -Ss '%S' "^(${providerspkgs[*]})$"))
            [[ " ${provided[*]} " =~ " ${providersdeps[$i]} " ]] && continue
        fi

        if (( ! NOCONFIRM && "${#providers[*]}" > 1 )); then
            Note "i" $"${WHITE}There are ${#providers[@]} providers available for ${providersdeps[$i]}:${ALL_OFF}"
            expac -S1 '   %!) %n (%r) ' "${providers[@]}"

            nb=-1
            providersnb="$[[ "${providers[@]}" -1 ]]" # count from 0
            while [[ "$nb" -lt 0 || "$nb" -ge "${#providers}" ]]; do
                printf "\n%s " $"Enter a number (default=0):"
                case "$TERM" in
                    dumb)
                    read -r nb
                    ;;
                    *)
                    read -r -n "${#providersnb}" nb
                    printf '\n'
                    ;;
                esac

                case "$nb" in
                    [0-9]|[0-9][0-9]) if [[ "$nb" -lt 0 || "$nb" -ge "${#providers[@]}" ]]; then
                            printf '\n'
                            Note "f" $"invalid value: $nb is not between 0 and $providersnb" && ((i--))
                        else
                            break
                        fi;;
                    '') nb=0;;
                    *) Note "f" $"invalid number: $nb";;
                esac
            done
        else
            nb=0
        fi
        providerspkgs+=("${providers[$nb]}")
    done

    # add selected providers to repo deps
    repodepspkgs+=("${providerspkgs[@]}")

    # store for installation
    repoprovidersconflictingpkgs+=("${providerspkgs[@]}")

    FindDepsRepoProvider "${providerspkgs[@]}"

    # get binary packages info
    if [[ "${repodepspkgs[*]}" ]]; then
        repodepspkgs=($(expac -S1 '%n' "${repodepspkgs[@]}" | sort -u))
        repodepsSver=($(expac -S1 '%v' "${repodepspkgs[@]}"))
        repodepsQver=($(expac -Q '%v' "${repodepspkgs[@]}"))
        repodepsSrepo=($(expac -S1 '%r/%n' "${repodepspkgs[@]}"))
    fi
}

ConflictChecks() {
    local allQprovides allQconflicts Aprovides Aconflicts aurconflicts aurAconflicts Qrequires i j
    local k l repodepsprovides repodepsconflicts checkedrepodepsconflicts repodepsconflictsname
    local repodepsconflictsver localver repoconflictingpkgs
    # global deps depsAname aurdepspkgs aurconflictingpkgs aurconflictingpkgskeep aurconflictingpkgsrm
    # global depsQver repodepspkgs repoconflictingpkgskeep repoconflictingpkgsrm repoprovidersconflictingpkgs
    Note "i" $"looking for inter-conflicts..."

    allQprovides=($(expac -Q '%n'))
    allQprovides+=($(expac -Q '%S')) # no versioning
    allQconflicts=($(expac -Q '%C'))

    # AUR conflicts
    Aprovides=("${depsAname[@]}")
    Aprovides+=($(GetInfo "Provides"))
    Aconflicts=($(GetInfo "Conflicts"))
    # remove AUR versioning
    Aprovides=("${Aprovides[@]%%[><=]*}")
    Aconflicts=("${Aconflicts[@]%%[><=]*}")
    aurconflicts=($(CommArr 'Aprovides' 'allQconflicts' '-12'))
    aurconflicts+=($(CommArr 'Aconflicts' 'allQprovides' '-12'))
    aurconflicts=($(printf '%s\n' "${aurconflicts[@]}" | sort -u))

    for i in "${aurconflicts[@]}"; do
        unset aurAconflicts
        [[ " ${depsAname[*]} " =~ " $i " ]] && aurAconflicts=("$i")
        for j in "${depsAname[@]}"; do
            [[ " $(GetInfo "Conflicts" "$j") " =~ " $i " ]] && aurAconflicts+=("$j")
        done

        for j in "${aurAconflicts[@]}"; do
            unset k Aprovides
            read -rd' ' < <(expac -Qs '%n %P' "^$i$") k
            (( ! INSTALLPKG )) && [[ ! " ${aurdepspkgs[*]} " =~ " $j " ]] && continue # download only
            [[ "$j" = "$k" || ! "$k" ]] && continue # skip if reinstalling or if no conflict exists

            Aprovides=("$j")
            if (( ! NOCONFIRM )) && [[ ! " ${aurconflictingpkgs[*]} " =~ " $k " ]]; then
                if ! Proceed "n" $"$j and $k are in conflict ($i). Remove $k?"; then
                    aurconflictingpkgs+=("$j" "$k")
                    aurconflictingpkgskeep+=("$j")
                    aurconflictingpkgsrm+=("$k")
                    for k in "${!depsAname[@]}"; do
                        [[ " ${depsAname[$l]} " =~ "$k" ]] && read -rd' ' < <(expac -Qs '%v' "^$k$") depsQver[$l]
                    done
                    Aprovides+=($(GetInfo "Provides" "$j"))
                    # remove AUR versioning
                    Aprovides=("${Aprovides[@]%%[><=]*}")
                    [[ ! " ${Aprovides[*]} ${aurconflictingpkgsrm[*]} " =~ " $k " ]] && CheckRequires "$k"
                    break
                else
                    Note "f" $"unresolvable package conflicts detected"
                    Note "f" $"failed to prepare transaction (conflicting dependencies)"
                    if (( UPGRADE )); then
                        Qrequires=($(expac -Q '%N' "$i"))
                        Note "e" $"$j and $k are in conflict (required by ${Qrequires[*]})" "$E_INSTALL_DEPS_FAILED"
                    else
                        Note "e" $"$j and $k are in conflict" "$E_INSTALL_DEPS_FAILED"
                    fi
                fi
            fi
            Aprovides+=($(GetInfo "Provides" "$j"))
            # remove AUR versioning
            Aprovides=("${Aprovides[@]%%[><=]*}")
            [[ ! " ${Aprovides[*]} ${aurconflictingpkgsrm[*]} " =~ " $k " ]] && CheckRequires "$k"
        done
    done

    NothingToDo "${deps[@]}"

    # repo conflicts
    if [[ "${repodepspkgs[*]}" ]]; then
        repodepsprovides=("${repodepspkgs[@]}")
        repodepsprovides+=($(expac -S1 '%S' "${repodepspkgs[@]}")) # no versioning
        repodepsconflicts=($(expac -S1 '%H' "${repodepspkgs[@]}"))

        # versioning check
        unset checkedrepodepsconflicts
        for i in "${!repodepsconflicts[@]}"; do
            unset repodepsconflictsname repodepsconflictsver localver
            repodepsconflictsname="${repodepsconflicts[$i]%%[><=]*}"
            repodepsconflictsver="${repodepsconflicts[$i]##*[><=]}"
            local localver="$(expac -Q '%v' "$repodepsconflictsname")"
            local repodepsconflictsverdiff="$(vercmp "$repodepsconflictsver" "$localver")"

            if [[ "$localver" ]]; then
                case "${repodepsconflicts[$i]}" in
                    *">="*) (( "$repodepsconflictsverdiff" >= 0 )) && continue;;
                    *"<="*) (( "$repodepsconflictsverdiff" <= 0 )) && continue;;
                    *">"*)  (( "$repodepsconflictsverdiff" > 0 ))  && continue;;
                    *"<"*)  (( "$repodepsconflictsverdiff" < 0 ))  && continue;;
                    *"="*)  (( "$repodepsconflictsverdiff" = 0 ))  && continue;;
                esac
                checkedrepodepsconflicts+=("$repodepsconflictsname")
            fi
        done

        repoconflicts+=($(CommArr 'repodepsprovides' 'allQconflicts' '-12'))
        repoconflicts+=($(CommArr 'checkedrepodepsconflicts' 'allQprovides' '-12'))
        repoconflicts=($(printf '%s\n' "${repoconflicts[@]}" | sort -u))
    fi

    for i in "${repoconflicts[@]}"; do
        unset Qprovides
        unset j && read -rd' ' < <(expac -Ss '%n %C %S' "^$i$") j
	    unset k && read -rd' ' < <(expac -Qs '%n %C %S' "^$i$") k
        [[ "$j" = "$k" || ! "$k" ]] && continue # skip when no conflict with repopkgs
        if (( ! NOCONFIRM )) && [[ ! " ${repoconflictingpkgs[*]} " =~ " $k " ]]; then
            if ! Proceed "n" $"$j and $k are in conflict ($i). Remove $k?"; then
                repoconflictingpkgs+=("$j" "$k")
                repoconflictingpkgskeep+=("$j")
                repoconflictingpkgsrm+=("$k")
                repoprovidersconflictingpkgs+=("$j")
                Qprovides=($(expac -Ss '%S' "^$k$"))
                [[ ! " ${Qprovides[*]} ${repoconflictingpkgsrm[*]} " =~ " $k " ]] && CheckRequires "$k"
                break
            else
                Note "f" $"unresolvable package conflicts detected"
                Note "f" $"failed to prepare transaction (conflicting dependencies)"
                if (( UPGRADE )); then
                    Qrequires=($(expac -Q '%N' "$i"))
                    Note "e" $"$j and $k are in conflict (required by ${Qrequires[*]})" "$E_INSTALL_DEPS_FAILED"
                else
                    Note "e" $"$j and $k are in conflict" "$E_INSTALL_DEPS_FAILED"
                fi
            fi
        fi
        Qprovides=($(expac -Ss '%S' "^$k$"))
        [[ ! " ${Qprovides[*]} " =~ " $k " ]] && CheckRequires "$k"
    done
}

ReinstallChecks() {
    local i depsAtmp
    # global aurpkgs aurdepspkgs deps aurconflictingpkgs depsAname depsQver depsAver depsAood depsAmain
    depsAtmp=("${depsAname[@]}")
    for i in "${!depsAtmp[@]}"; do
        [[ ! " ${aurpkgs[*]} " =~ " ${depsAname[$i]} " ]] ||
            [[ " ${aurconflictingpkgs[*]} " =~ " ${depsAname[$i]} " ]] && continue
        [[ ! "${depsQver[$i]}" || "${depsQver[$i]}" = '%' ]] ||
            [[ "$(vercmp "${depsAver[$i]}" "${depsQver[$i]}")" -gt 0 ]] && continue
        (( ! INSTALLPKG )) && [[ ! " ${aurdepspkgs[*]} " =~ " ${depsAname[$i]} " ]] && continue
        if [[ "${depsAname[$i]}" =~ $vcs ]]; then
            Note "w" $"${WHITE}${depsAname[$i]}${ALL_OFF} latest revision -- fetching"
        else
            if (( ! NEEDED )); then
                Note "w" $"${WHITE}${depsAname[$i]}-${depsQver[$i]}${ALL_OFF} is up to date -- reinstalling"
            else
                Note "w" $"${WHITE}${depsAname[$i]}-${depsQver[$i]}${ALL_OFF} is up to date -- skipping"
                mapfile -t < <(printf ' %s \n' "${deps[@]}") deps
                deps=($(printf '%s\n' "${deps[@]// ${depsAname[$i]} /}"))
                unset "depsAname[$i]" "depsQver[$i]" "depsAver[$i]" "depsAood[$i]" "depsAmain[$i]"
            fi
        fi
    done
    (( NEEDED )) && depsAname=("${depsAname[@]}") && depsQver=("${depsQver[@]}") &&
        depsAver=("${depsAver[@]}") && depsAood=("${depsAood[@]}") && depsAmain=("${depsAmain[@]}")
    NothingToDo "${deps[@]}"
}

OutOfDateChecks() {
    local i
    # global depsAname depsAver depsAood
    for i in "${!depsAname[@]}"; do
        (( depsAood[$i] > 0 )) &&
            Note "w" $"${WHITE}${depsAname[$i]}-${depsAver[$i]}${ALL_OFF} has been flagged ${RED}out of date${ALL_OFF} on ${YELLOW}$(printf '%(%c)T\n' "${depsAood[$i]}")${ALL_OFF}"
    done
}

OrphanChecks() {
    local i
    # global depsAname depsAver depsAmain
    for i in "${!depsAname[@]}"; do
        [[ "${depsAmain[$i]}" = 'null' || ! "${depsAmain[$i]}" ]] &&
            Note "w" $"${WHITE}${depsAname[$i]}-${depsAver[$i]}${ALL_OFF} is ${RED}orphaned${ALL_OFF} in AUR"
    done
}

Prompt() {
    local i binaryksize sumk summ builtpkg cachedpkgs stroldver strnewver strsize depsver
    local repodepspkgsver strrepodlsize strrepoinsize strsumk strsumm lreposizelabel lreposize
    # global repodepspkgs repodepsSver depsAname depsAver depsArepo depsAcached lname lver lsize
    # global deps depsQver repodepspkgs repodepsSrepo repodepsQver repodepsSver
    # compute binary size
    if [[ "${repodepspkgs[*]}" ]]; then
        binaryksize=($(expac -S1 '%k' "${repodepspkgs[@]}"))
        binarymsize=($(expac -S1 '%m' "${repodepspkgs[@]}"))
        sumk=0
        summ=0
        for i in "${!repodepspkgs[@]}"; do
            GetBuiltPkg "${repodepspkgs[$i]}-${repodepsSver[$i]}" "$(pacman-conf CacheDir)"
            [[ "$builtpkg" ]] && binaryksize[$i]=0
            sumk="$((sumk + "${binaryksize[$i]}"))"
            summ="$((summ + "${binarymsize[$i]}"))"
        done
        sumk="$((sumk / 1048576)).$((sumk / 1024 % 1024 * 100 / 1024))"
        summ="$((summ / 1048576)).$((summ / 1024 % 1024 * 100 / 1024))"
    fi

    # cached packages check
    for i in "${!depsAname[@]}"; do
        [[ ! "$PKGDEST" ]] || (( REBUILD )) && break
        GetBuiltPkg "${depsAname[$i]}-${depsAver[$i]}" "$PKGDEST"
        [[ "$builtpkg" ]] && cachedpkgs+=("${depsAname[$i]}") && depsAcached[$i]=$"(cached)" || depsAcached[$i]=""
        unset builtpkg
    done

    if [[ "$(pacman-conf VerbosePkgLists)" ]]; then
        straurname=$"AUR Packages  (${#deps[@]})"; strreponame=$"Repo Packages (${#repodepspkgs[@]})"
        stroldver=$"Old Version"; strnewver=$"New Version"; strsize=$"Download Size"
        depsArepo=("${depsAname[@]/#/aur/}")
        lname="$(GetLength "${depsArepo[@]}" "${repodepsSrepo[@]}" "$straurname" "$strreponame")"
        lver="$(GetLength "${depsQver[@]}" "${depsAver[@]}" "${repodepsQver[@]}" "${repodepsSver[@]}" "$stroldver" "$strnewver")"
        lsize="$(GetLength "$strsize")"

        # local version column cleanup
        for i in "${!deps[@]}"; do
            [[ "${depsQver[$i]}" =~ '%' ]] && unset depsQver[$i]
        done
        # show detailed output
        printf "\n${WHITE}%-${lname}s  %-${lver}s  %-${lver}s${ALL_OFF}\n\n" "$straurname" "$stroldver" "$strnewver"
        for i in "${!deps[@]}"; do
            printf "%-${lname}s  ${RED}%-${lver}s${ALL_OFF}  ${GREEN}%-${lver}s${ALL_OFF}  %${lsize}s\n" "${depsArepo[$i]}" "${depsQver[$i]}" "${depsAver[$i]}" "${depsAcached[$i]}";
        done

        if [[ "${repodepspkgs[*]}" ]]; then
            for i in "${!repodepspkgs[@]}"; do
                binarysize[$i]="$((binaryksize[$i] / 1048576)).$((binaryksize[$i] / 1024 % 1024 * 100 / 1024))"
            done
            printf "\n${WHITE}%-${lname}s  %-${lver}s  %-${lver}s  %s${ALL_OFF}\n\n" "$strreponame" "$stroldver" "$strnewver" "$strsize"
            for i in "${!repodepspkgs[@]}"; do
                printf "%-${lname}s  ${RED}%-${lver}s${ALL_OFF}  ${GREEN}%-${lver}s${ALL_OFF}  %${lsize}s\n" "${repodepsSrepo[$i]}" "${repodepsQver[$i]}" "${repodepsSver[$i]}" $"${binarysize[$i]} MiB";
            done
        fi
    else
        # show version
        for i in "${!deps[@]}"; do
            depsver="${depsver}${depsAname[$i]}-${depsAver[$i]}  "
        done
        for i in "${!repodepspkgs[@]}"; do
            repodepspkgsver="${repodepspkgsver}${repodepspkgs[$i]}-${repodepsSver[$i]}  "
        done
        printf "\n${WHITE}%-16s${ALL_OFF} %s\n" $"AUR Packages  (${#deps[@]})" "$depsver"
        [[ "${repodepspkgs[*]}" ]] &&
            printf "${WHITE}%-16s${ALL_OFF} %s\n" $"Repo Packages (${#repodepspkgs[@]})" "$repodepspkgsver"
    fi

    if [[ "${repodepspkgs[*]}" ]]; then
        strrepodlsize=$"Repo Download Size:"; strrepoinsize=$"Repo Installed Size:"; strsumk=$"$sumk MiB"
        strsumm=$"$summ MiB" lreposizelabel="$(GetLength "$strrepodlsize" "$strrepoinsize")"
        lreposize="$(GetLength "$strsumk" "$strsumm")"
        printf "\n${WHITE}%-${lreposizelabel}s${ALL_OFF}  %${lreposize}s\n" "$strrepodlsize" "$strsumk"
        printf "${WHITE}%-${lreposizelabel}s${ALL_OFF}  %${lreposize}s\n" "$strrepoinsize" "$strsumm"
    fi

    printf '\n'
    if (( INSTALLPKG )); then
        Proceed "y" $"Proceed with installation?" || exit "$E_FAIL"
    else
        Proceed "y" $"Proceed with download?" || exit "$E_FAIL"
    fi
}

DownloadPkgs() {
    local i
    # global basepkgs
    Note "i" $"${WHITE}Retrieving package(s)...${ALL_OFF}"
    GetPkgbase "$@"

    # no results check
    [[ ! "${basepkgs[*]}" ]] && Note "e" $"no results found" "$E_INSTALL_DEPS_FAILED"

    # reset
    for i in "${basepkgs[@]}"; do
        if [[ -d "$clonedir/$i" ]]; then
            git -C "$clonedir/$i" reset --hard HEAD -q # updated pkgver of vcs packages block pull
            [[ "$displaybuildfiles" = diff ]] &&
                git -C "$clonedir/$i" rev-parse HEAD > "$clonedir/$i/.git/HEAD.prev"
        fi
    done

    # clone
    auracle -C "$clonedir" clone "$@" >/dev/null ||
        Note "e" $"failed to retrieve packages" "$E_INSTALL_DEPS_FAILED"
}

EditPkgs() {
    local viewed i j erreditpkg
    # global cachedpkgs installscripts editor
    (( NOEDIT )) && return
    unset viewed
    for i in "$@"; do
        [[ " ${cachedpkgs[*]} " =~ " $i " ]] && continue
        GetInstallScripts "$i"
        if (( ! PACE )); then
            if [[ "$displaybuildfiles" = diff && -e "$clonedir/$i/.git/HEAD.prev" ]]; then
                local prev="$(<"$clonedir/$i/.git/HEAD.prev")"
                # show diff
                if git -C "$clonedir/$i" diff --quiet --no-ext-diff "$prev" -- . ':!\.SRCINFO'; then
                    Note "w" $"${WHITE}$i${ALL_OFF} build files are up-to-date -- skipping"
                else
                    if Proceed "y" $"View $i build files diff?"; then
                        git -C "$clonedir/$i" diff --no-ext-diff "$prev" -- . ':!\.SRCINFO' ||
                            erreditpkg+=("$i")
                        Note "i" $"${WHITE}$i${ALL_OFF} build files diff viewed"; viewed=1
                    fi
                fi
            elif [[ ! "$displaybuildfiles" = none ]]; then
                # show pkgbuild
                if Proceed "y" $"View $i PKGBUILD?"; then
                    if [[ -e "$clonedir/$i/PKGBUILD" ]]; then
                        "$editor" "$clonedir/$i/PKGBUILD" &&
                            Note "i" $"${WHITE}$i${ALL_OFF} PKGBUILD viewed" || erreditpkg+=("$i")
                    else
                        Note "e" $"Could not open ${WHITE}$i${ALL_OFF} PKGBUILD" "$E_MISSING_FILE"
                    fi
                fi
                # show install script
                if [[ "${installscripts[*]}" ]]; then
                    for j in "${installscripts[@]}"; do
                        if Proceed "y" $"View $j script?"; then
                            if [[ -e "$clonedir/$i/$j" ]]; then
                                "$editor" "$clonedir/$i/$j" &&
                                    Note "i" $"${WHITE}$j${ALL_OFF} script viewed" ||
                                    erreditpkg+=("$i")
                            else
                                Note "e" $"Could not open ${WHITE}$j${ALL_OFF} script" "$E_MISSING_FILE"
                            fi
                        fi
                    done
                fi
            fi
        else
            # show pkgbuild and install script
            if [[ -e "$clonedir/$i/PKGBUILD" ]]; then
                "$editor" "$clonedir/$i/PKGBUILD" &&
                    Note "i" $"${WHITE}$i${ALL_OFF} PKGBUILD viewed" || erreditpkg+=("$i")
            else
                Note "e" $"Could not open ${WHITE}$i${ALL_OFF} PKGBUILD" "$E_MISSING_FILE"
            fi
            if [[ "${installscripts[*]}" ]]; then
                for j in "${installscripts[@]}"; do
                    if [[ -e "$clonedir/$i/$j" ]]; then
                        "$editor" "$clonedir/$i/$j" &&
                            Note "i" $"${WHITE}$j${ALL_OFF} script viewed" || erreditpkg+=("$i")
                    else
                        Note "e" $"Could not open ${WHITE}$j${ALL_OFF} script" "$E_MISSING_FILE"
                    fi
                done
            fi
        fi
    done

    if [[ "${erreditpkg[*]}" ]]; then
        for i in "${erreditpkg[@]}"; do
            Note "f" $"${WHITE}$i${ALL_OFF} errored on exit"
        done
        exit "$E_FAIL"
    fi

    if [[ "$displaybuildfiles" = diff && "$viewed" ]]; then
        if (( INSTALLPKG )); then
            Proceed "y" $"Proceed with installation?" || exit
        else
            Proceed "y" $"Proceed with download?" || exit
        fi
    fi
}

MakePkgs() {
    local i j k oldorphanpkgs neworphanpkgs orphanpkgs oldoptionalpkgs newoptionalpkgs optionalpkgs
    local errinstall pkgsdepslist vcsclients vcschecked aurpkgsAver aurpkgsQver
    local builtpkgs builtdepspkgs basepkgsupdate checkpkgsdepslist deplist isaurdeps makedeps
    # global deps basepkgs sudoloop pkgsbase pkgsdeps aurpkgs aurdepspkgs builtpkg errmakepkg
    # global repoprovidersconflictingpkgs

    # download
    DownloadPkgs "${deps[@]}"
    EditPkgs "${basepkgs[@]}"

    # current orphan and optional packages
    oldorphanpkgs=($("$PACMAN" -Qdtq))
    oldoptionalpkgs=($("$PACMAN" -Qdttq))
    oldoptionalpkgs=($(CommArr 'oldorphanpkgs' 'oldoptionalpkgs' '-13'))

    # initialize sudo
    if sudo -n "$PACMAN" -V > /dev/null || sudo -v; then
        [[ "$sudoloop" = true ]] && SudoV &
    fi

    # split packages support
    for i in "${!pkgsbase[@]}"; do
        for j in "${!deps[@]}"; do
            [[ "${pkgsbase[$i]}" = "${pkgsbase[$j]}" && ! " ${pkgsdeps[*]} " =~ " ${deps[$j]} " ]] &&
                pkgsdeps+=("${deps[$j]}")
        done
        pkgsdeps+=("%")
    done
    deplist="${pkgsdeps[@]}"; deplist="${deplist// % /|}"; deplist="${deplist//%}"
    deplist="${deplist// /,}"; deplist="${deplist//|/ }"; deplist="${deplist%, }"
    pkgsdeps=($(printf '%s\n' ${deplist% ,})); pkgsdeps=("${pkgsdeps[@]%,}")

    # reverse deps order
    for i in "${!basepkgs[@]}"; do
        basepkgsrev[$i]="${basepkgs[-i-1]}"
    done
    basepkgs=("${basepkgsrev[@]}") && unset basepkgsrev
    for i in "${!pkgsdeps[@]}"; do
        pkgsdepsrev[$i]="${pkgsdeps[-i-1]}"
    done
    pkgsdeps=("${pkgsdepsrev[@]}") && unset pkgsdepsrev

    # integrity check
    for i in "${!basepkgs[@]}"; do
        # get split packages list
        read -rd',' -a pkgsdepslist <<< "${pkgsdeps[$i]}"

        # cache check
        unset builtpkg
        if [[ ! "${basepkgs[$i]}" =~ $vcs ]]; then
            for j in "${pkgsdepslist[@]}"; do
                [[ "$PKGDEST" ]] && (( ! REBUILD )) && GetBuiltPkg "$j-$(GetInfo "Version" "$j")" "$PKGDEST"
            done
        fi

        # install vcs clients (checking pkgbase extension only does not take fetching specific
        # commit into account)
        unset vcsclients
        makedeps=($(GetInfo "MakeDepends" "${basepkgs[$i]}"))
        for k in git subversion mercurial bzr cvs darcsl; do
            [[ " ${makedeps[*]} " =~ " $k " ]] && vcsclients+=("$k")
        done
        unset makedeps
        for j in "${vcsclients[@]}"; do
            if [[ ! "${vcschecked[*]}" =~ "$j" ]]; then
                expac -Qs '' "^$j$" || sudo "$PACMAN" -S --asdeps --noconfirm -- "$j"
                vcschecked+=("$j")
            fi
        done

        if [[ ! "$builtpkg" ]] || (( REBUILD )); then
            cd "${clonedir:?}/${basepkgs[$i]}" || exit "$E_MISSING_FILE"
            Note "i" $"Checking ${WHITE}${pkgsdeps[$i]}${ALL_OFF} integrity..."
            if [[ "$silent" = true ]]; then
                makepkg -f --verifysource "${MAKEPKG_OPTS[@]}" &>/dev/null
            else
                makepkg -f --verifysource "${MAKEPKG_OPTS[@]}" >/dev/null
            fi
            (($? > 0)) && errmakepkg+=("${pkgsdeps[$i]}")
            # extraction, prepare and pkgver update
            Note "i" $"Preparing ${WHITE}${pkgsdeps[$i]}${ALL_OFF}..."
            if [[ "$silent" = true ]]; then
                makepkg -od --skipinteg "${MAKEPKG_OPTS[@]}" &>/dev/null
            else
                makepkg -od --skipinteg "${MAKEPKG_OPTS[@]}"
            fi
            (($? > 0)) && errmakepkg+=("${pkgsdeps[$i]}")
        fi
    done
    if [[ "${errmakepkg[*]}" || "${errinstall[*]}" ]]; then
        for i in "${errmakepkg[@]}"; do
            Note "f" $"failed to verify integrity or prepare ${WHITE}$i${ALL_OFF} package"
        done
        # remove sudo lock
        rm -f "${tmpdir:?}/pacaur.sudov.lck"
        exit "$E_FAIL"
    fi

    # check database lock
    [[ -e "/var/lib/pacman/db.lck" ]] && Note "e" $"db.lck exists in /var/lib/pacman" "$E_FAIL"

    # set build lock
    [[ -e "$tmpdir/pacaur.build.lck" ]] && Note "e" $"pacaur.build.lck exists in $tmpdir" "$E_FAIL"
    > "$tmpdir/pacaur.build.lck"

    # install provider packages and repo conflicting packages that makepkg --noconfirm cannot handle
    if [[ "${repoprovidersconflictingpkgs[*]}" ]]; then
        Note "i" $"Installing ${WHITE}${repoprovidersconflictingpkgs[@]}${ALL_OFF} dependencies..."
        sudo "$PACMAN" -S ${repoprovidersconflictingpkgs[@]} --ask 36 --asdeps --noconfirm
    fi

    # main
    for i in "${!basepkgs[@]}"; do
        # get split packages list
        read -rd',' -a pkgsdepslist <<< "${pkgsdeps[$i]}"

        cd "$clonedir/${basepkgs[$i]}" || exit "$E_MISSING_FILE"
        # retrieve updated version
        mapfile -d'-' -t < <(makepkg --packagelist) k && aurpkgsAver="${k[-3]}-${k[-2]}"; unset k
        # build devel if necessary only (supported protocols only)
        if [[ "${basepkgs[$i]}" =~ $vcs ]]; then
            # check split packages update
            unset basepkgsupdate checkpkgsdepslist
            for j in "${pkgsdepslist[@]}"; do
                read -rd' ' < <(expac -Qs '%v' "^$j$") aurpkgsQver
                if (( NEEDED && ! REBUILD )) && [[ "$aurpkgsQver" ]] &&
                    (( "$(vercmp "$aurpkgsQver" "$aurpkgsAver")" >= 0 )); then
                    Note "w" $"${WHITE}$j${ALL_OFF} is up-to-date -- skipping" && continue
                else
                    basepkgsupdate='true'; checkpkgsdepslist+=("$j")
                fi
            done
            [[ "$basepkgsupdate" ]] && pkgsdepslist=("${checkpkgsdepslist[@]}") || continue
        fi

        # check package cache
        for j in "${pkgsdepslist[@]}"; do
            unset builtpkg
            [[ "$PKGDEST" ]] && (( ! REBUILD )) && GetBuiltPkg "$j-$aurpkgsAver" "$PKGDEST"
            if [[ "$builtpkg" ]]; then
                if [[ " ${aurdepspkgs[*]} " =~ " $j " ]] || (( INSTALLPKG )); then
                    Note "i" $"Installing ${WHITE}$j${ALL_OFF} cached package..."
                    sudo "$PACMAN" -U --ask 36 ${PACMAN_OPTS[@]/--quiet} --noconfirm -- "$builtpkg"
                    [[ " ${aurpkgs[*]} " =~ " $j " ]] ||
                        sudo "$PACMAN" -D "$j" --asdeps ${PACMAN_OPTS[@]} &>/dev/null
                else
                    Note "w" $"Package ${WHITE}$j${ALL_OFF} already available in cache"
                fi
                pkgsdeps=("${pkgsdeps[@]/#$j,}"); pkgsdeps=("${pkgsdeps[@]/%,$j}")
                pkgsdeps=("${pkgsdeps[@]//,$j,/,}")
                for k in "${!pkgsdeps[@]}"; do
                    [[ "${pkgsdeps[k]}" = "$j" ]] && pkgsdeps[k]='%'
                done
                continue
            fi
        done
        [[ "${pkgsdeps[$i]}" = '%' ]] && continue

        # build
        Note "i" $"Building ${WHITE}${pkgsdeps[$i]}${ALL_OFF} package(s)..."

        # install then remove binary deps
        MAKEPKG_OPTS=("${MAKEPKG_OPTS[@]/-r/}")

        if (( ! INSTALLPKG )); then
            unset isaurdeps
            for j in "${pkgsdepslist[@]}"; do
                [[ " ${aurdepspkgs[*]} " =~ " $j " ]] && isaurdeps=1
            done
            [[ "$isaurdeps" ]] && MAKEPKG_OPTS+=("-r")
        fi

        if [[ "$silent" = true ]]; then
            makepkg -sefc "${MAKEPKG_OPTS[@]}" --noconfirm &>/dev/null
        else
            makepkg -sefc "${MAKEPKG_OPTS[@]}" --noconfirm
        fi

        # error check
        (($? > 0)) && errmakepkg+=("${pkgsdeps[$i]}") && continue # skip install

        # retrieve filename
        unset builtpkgs builtdepspkgs
        for j in "${pkgsdepslist[@]}"; do
            unset builtpkg
            if [[ "$PKGDEST" ]]; then
                GetBuiltPkg "$j-$aurpkgsAver" "$PKGDEST"
            else
                GetBuiltPkg "$j-$aurpkgsAver" "${clonedir:?}/${basepkgs[$i]}"
            fi
            [[ " ${aurdepspkgs[*]} " =~ " $j " ]] && builtdepspkgs+=("$builtpkg") || builtpkgs+=("$builtpkg")
        done

        # install
        if (( INSTALLPKG || ! "${#builtpkgs[*]}" )); then
            Note "i" $"Installing ${WHITE}${pkgsdeps[$i]}${ALL_OFF} package(s)..."
            sudo "$PACMAN" -U ${builtdepspkgs[@]} ${builtpkgs[@]} --ask 36 ${PACMAN_OPTS[@]/--quiet} --noconfirm
        fi

        # set dep status
        if (( INSTALLPKG )); then
            for j in "${pkgsdepslist[@]}"; do
                [[ ! " ${aurpkgs[*]} " =~ " $j " ]] && sudo "$PACMAN" -D "$j" --asdeps &>/dev/null
                (( ASDEPS )) && sudo "$PACMAN" -D "$j" --asdeps &>/dev/null
                (( ASEXPLICIT )) && sudo "$PACMAN" -D "$j" --asexplicit &>/dev/null
            done
        fi
    done

    # remove AUR deps
    if (( ! INSTALLPKG )); then
        [[ "${aurdepspkgs[*]}" ]] && aurdepspkgs=($(expac -Q '%n' "${aurdepspkgs[@]}"))
        [[ "${aurdepspkgs[*]}" ]] && Note "i" $"Removing installed AUR dependencies..." &&
            sudo "$PACMAN" -Rsn "${aurdepspkgs[@]}" --noconfirm
        # readd removed conflicting packages
        [[ "${aurconflictingpkgsrm[*]}" ]] &&
            sudo "$PACMAN" -S ${aurconflictingpkgsrm[@]} --ask 36 --asdeps --needed --noconfirm
        [[ "${repoconflictingpkgsrm[*]}" ]] &&
            sudo "$PACMAN" -S ${repoconflictingpkgsrm[@]} --ask 36 --asdeps --needed --noconfirm
    fi

    # remove locks
    rm "${tmpdir:?}/pacaur.build.lck"
    rm -f "${tmpdir:?}/pacaur.sudov.lck"

    # new orphan and optional packages check
    orphanpkgs=($("$PACMAN" -Qdtq))
    neworphanpkgs=($(CommArr 'oldorphanpkgs' 'orphanpkgs' '-13'))
    for i in "${neworphanpkgs[@]}"; do
        Note "w" $"${WHITE}$i${ALL_OFF} is now an ${YELLOW}orphan${ALL_OFF} package"
    done
    optionalpkgs=($("$PACMAN" -Qdttq))
    optionalpkgs=($(CommArr 'orphanpkgs' 'optionalpkgs' '-13'))
    newoptionalpkgs=($(CommArr 'oldoptionalpkgs' 'optionalpkgs' '-13'))
    for i in "${newoptionalpkgs[@]}"; do
        Note "w" $"${WHITE}$i${ALL_OFF} is now an ${YELLOW}optional${ALL_OFF} package"
    done

    # makepkg and install failure check
    if [[ "${errmakepkg[*]}" ]]; then
        for i in "${errmakepkg[@]}"; do
            Note "f" $"failed to build ${WHITE}$i${ALL_OFF} package(s)"
        done
        exit "$E_PACKAGE_FAILED"
    fi
    [[ "${errinstall[*]}" ]] && exit  "$E_INSTALL_FAILED"
}

CleanCache() {
    local i cachepkgs
    cachedir=($(pacman-conf CacheDir))
    [[ "${cachedir[*]}" ]] && cachedir=("${cachedir[@]%/}") && PKGDEST="${PKGDEST%/}"
    if [[ "$PKGDEST" && ! " ${cachedir[*]} " =~ " $PKGDEST " ]]; then
        (( CCOUNT == 1 )) && printf "\n%s\n %s\n" $"Packages to keep:" $"All locally installed packages"
        printf "\n%s %s\n" $"AUR cache directory:" "$PKGDEST"
        if (( CCOUNT == 1 )); then
            if Proceed "y" $"Do you want to remove all other packages from AUR cache?"; then
                printf "%s\n" $"removing old packages from cache..."
                cachepkgs=("${PKGDEST:?}"/*); cachepkgs=("${cachepkgs[@]##*/}")
                for i in "${cachepkgs[@]%-*}"; do
                    [[ "$i" != "$(expac -Q '%n-%v' "${i%-*-*}")" ]] && rm "${PKGDEST:?}/$i"-*
                done
            fi
        else
            Proceed "n" $"Do you want to remove ALL files from AUR cache?" ||
                printf "%s\n" $"removing all files from AUR cache..." &&
                rm "${PKGDEST:?}"/* &>/dev/null
        fi
    fi

    if [[ -d "$SRCDEST" ]]; then
        (( CCOUNT == 1 )) &&
            printf "\n%s\n %s\n" $"Sources to keep:" $"All development packages sources"
        printf "\n%s %s\n" $"AUR source cache directory:" "$SRCDEST"
        if (( CCOUNT == 1 )); then
            Proceed "y" $"Do you want to remove all non development files from AUR source cache?" &&
                printf "%s\n" $"removing non development files from source cache..." &&
                rm -f "${SRCDEST:?}"/* &>/dev/null
        else
            Proceed "n" $"Do you want to remove ALL files from AUR source cache?" ||
                printf "%s\n" $"removing all files from AUR source cache..." &&
                rm -rf "${SRCDEST:?}"/*
        fi
    fi
    if [[ -d "$clonedir" ]]; then
        if (( CCOUNT == 1 )); then
            if [[ ! "${pkgs[*]}" ]]; then
                printf "\n%s\n %s\n" $"Clones to keep:" $"All locally installed clones"
            else
                printf "\n%s\n %s\n" $"Clones to keep:" $"All other locally installed clones"
            fi
        fi
        printf "\n%s %s\n" $"AUR clone directory:" "$clonedir"
        if (( CCOUNT == 1 )); then
            mapfile -t < <(expac -Q '%e' $("$PACMAN" -Qmq)) foreignpkgsbase
            # get target
            if [[ "${pkgs[*]}" ]]; then
                mapfile -t < <(expac -Q '%e' "${pkgs[@]}") pkgsbase
                mapfile -t < <(CommArr 'pkgsbase' 'foreignpkgsbase' '-12') aurpkgsbase
                if Proceed "y" $"Do you want to remove ${aurpkgsbase[*]} clones from AUR clone directory?"; then
                    printf "%s\n\n" $"removing uninstalled clones from AUR clone cache..."
                    for i in "${aurpkgsbase[@]}"; do
                        [[ -d "$clonedir/$i" ]] && rm -rf "${clonedir:?}/$i"
                    done
                fi
            else
                if Proceed "y" $"Do you want to remove all uninstalled clones from AUR clone directory?"; then
                    printf "%s\n\n" $"removing uninstalled clones from AUR clone cache..."
                    for i in "${clonedir:?}/"*; do
                        [[ -d "$i" && ! " ${foreignpkgsbase[*]} " =~ " $i " ]] &&
                            rm -rf "${clonedir:?}/$i"
                    done
                fi
                if [[ ! "$PKGDEST" || ! "$SRCDEST" ]]; then
                    if Proceed "y" $"Do you want to remove all untracked files from AUR clone directory?"; then
                        printf "%s\n" $"removing untracked files from AUR clone cache..."
                        for i in "${clonedir:?}/"*; do
                            [[ -d "$i" ]] &&
                                git --git-dir="$i/.git" --work-tree="$i" clean -ffdx &>/dev/null
                        done
                    fi
                fi
            fi
        else
            if ! Proceed "n" $"Do you want to remove ALL clones from AUR clone directory?"; then
                printf "%s\n" $"removing all clones from AUR clone cache..."
                for i in "${clonedir:?}/"*; do
                    [[ -d "$i" ]] && rm -rf "$i"
                done
            fi
        fi
    fi
    exit "$E_OK"
}

GetIgnoredPkgs() {
    # global ignoredpkgs
    ignoredpkgs+=($(pacman-conf IgnorePkg))
    ignoredpkgs=("${ignoredpkgs[@]//,/ }")
}

GetIgnoredGrps() {
    # global ignoredgrps
    ignoredgrps+=($(pacman-conf IgnoreGroup))
    ignoredgrps=("${ignoredgrps[@]//,/ }")
}

GetInstallScripts() {
    local installscriptspath
    # global installscripts
    [[ ! -d "$clonedir/$1" ]] && return
    unset installscriptspath installscripts
    shopt -s nullglob
    installscriptspath=($(printf '%s\n' "$clonedir/$1/"*'.install'))
    shopt -u nullglob
    [[ "${installscriptspath[*]}" ]] && installscripts=("${installscriptspath[@]##*/}")
}

GetBuiltPkg() {
    local ext
    # global builtpkg
    # check PKGEXT suffix first, then default .xz suffix for repository packages in pacman cache
    # and lastly all remaining suffixes in case PKGEXT is locally overridden
    for ext in "$PKGEXT" .pkg.tar{.xz,,.gz,.bz2,.lzo,.lrz,.Z}; do
        builtpkg="$2/$1-${CARCH}${ext}"
        [[ -f "$builtpkg" ]] || builtpkg="$2/$1-any${ext}"
        [[ -f "$builtpkg" ]] && break
    done
    [[ -f "$builtpkg" ]] || unset builtpkg
}

GetPkgbase() {
    local i
    # global pkgsbase basepkgs
    SetInfo "$@"
    for i in "$@"; do
        pkgsbase+=($(GetInfo "PackageBase" "$i"))
    done
    for i in "${pkgsbase[@]}"; do
        [[ " ${basepkgs[*]} " =~ " $i " ]] || basepkgs+=("$i")
    done
}

SetInfo() {
    # Usage: SetJson $@
    # Use auracle formatted info output for all aur packages passed to SetInfo, and sort it into
    # associated arrays, with the key always being a pkgname fields are delimited by \037, the unit
    # separator, to prevent the delimiter from being in the input and shifting the entire array
    unset Name PackageBase Version Maintainer OutOfDate Groups {,Make,Check}Depends Provides Conflicts
    [[ "$*" ]] || return
    declare -gA Name PackageBase Version Maintainer OutOfDate Groups {,Make,Check}Depends Provides Conflicts
    while IFS=$'\037' read -r Aname Abase Aver Amain Aood Agrps Adeps Amakedeps Acheckdeps Aprovs Aconfs; do
        Name[$Aname]="$Aname"
        PackageBase[$Aname]="$Abase"
        Version[$Aname]="$Aver"
        Maintainer[$Aname]="$Amain"
        OutOfDate[$Aname]="$Aood"
        Groups[$Aname]="$Agrps"
        Depends[$Aname]="$Adeps"
        MakeDepends[$Aname]="$Amakedeps"
        CheckDepends[$Aname]="$Acheckdeps"
        Provides[$Aname]="$Aprovs"
        Conflicts[$Aname]="$Aconfs"
    done < <(auracle info "$@" -F \
        $'{name}\037{pkgbase}\037{version}\037{maintainer}\037{outofdate:%s}\037{groups: }\037{depends: }\037{makedepends: }\037{checkdepends: }\037{provides: }\037{conflicts: }')
}

GetInfo() {
    local field="$1" pkgname="$2"

    [[ "$pkgname" ]] && field="${field}[$pkgname]" || field="${field}[@]"

    printf '%s\n' "${!field}"
}

CheckRequires() {
    local Qrequires=($(expac -Q '%N'))
    if [[ "${Qrequires[*]}" ]]; then
        Note "f" $"failed to prepare transaction (could not satisfy dependencies)"
        Note "e" $"${Qrequires[@]}: requires $@" "$E_INSTALL_DEPS_FAILED"
    fi
}

Proceed() {
    local answer ret readline=0

    [[ "$TERM" = dumb ]] || (( CLEANCACHE )) && readline=1
    case "$1" in
        y)  printf "${BLUE}%s${ALL_OFF} ${WHITE}%s${ALL_OFF}" "::" "$2 [Y/n] "
            (( NOCONFIRM )) && printf '\n' && return 0
            while true; do
                if (( readline )); then
                    read -r answer
                else
                    read -s -r -n 1 answer
                fi
                case "$answer" in
                    [Yy]|'') ret=0; break;;
                    [Nn]) ret=1; break;;
                    *) (( readline )) && ret=1 && break;;
                esac
            done;;
        n)  printf "${BLUE}%s${ALL_OFF} ${WHITE}%s${ALL_OFF}" "::" "$2 [y/N] "
            (( NOCONFIRM )) && printf '\n' && return 0
            while true; do
                if (( readline )); then
                    read -r answer
                else
                    read -s -r -n 1 answer
                fi
                case "$answer" in
                    [Nn]|'') ret=0; break;;
                    [Yy]) ret=1; break;;
                    *) (( readline )) && ret=0 && break;;
                esac
            done;;
    esac
    (( ! readline )) && printf '%s\n' "$answer"
    return "$ret"
}

Note() {
    case "$1" in
        i) printf '%b\n' "${BLUE}::${ALL_OFF} $2";;              # info
        w) printf '%b\n' "${YELLOW}warning:${ALL_OFF} $2" >&2;;  # warn
        f) printf '%b\n' "${RED}error:${ALL_OFF} $2" >&2;;       # fail
        e) printf '%b\n' "${RED}error:${ALL_OFF} $2" >&2;        # error
            exit "$3";;
    esac
}

GetLength() {
    local length=0 i
    for i in "$@"; do
        [[ "${#i}" -gt "$length" ]] && length="${#i}"
    done
    printf '%s\n' "$length"
}

NothingToDo() {
    [[ ! "$*" ]] && printf '%s\n' $" there is nothing to do" && exit "$E_OK" || return 0
}

SudoV() {
    > "$tmpdir/pacaur.sudov.lck"
    while [[ -e "$tmpdir/pacaur.sudov.lck" ]]; do
        sudo "$PACMAN" -V > /dev/null
        sleep 298
    done
}

CommArr() {
    # args are names of 2 arrays and outputs elements that are only in the 2nd
    local array1="$1[@]" array2="$2[@]"
    comm <(printf '%s\n' "${!array1}" | sort -u) <(printf '%s\n' "${!array2}" | sort -u) "$3"
}

trap Cancel INT
Cancel() {
    printf '\n'
    rm -f "${tmpdir:?}"/pacaur.{build,sudov}.lck
    exit
}

Usage() {
    printf "%s\n" $"usage:  pacaur <operation> [options] [target(s)] -- See also pacaur(8)"
    printf "%s\n" $"operations:"
    printf "%s\n" $" pacman extension"
    printf "%s\n" $"   -S, -Ss, -Si, -Sw, -Su, -Qu, -Sc, -Scc"
    printf "%s\n" $"                    extend pacman operations to the AUR"
    printf "%s\n" $" general"
    printf "%s\n" $"   -v, --version    display version information"
    printf "%s\n" $"   -h, --help       display help information"
    printf '\n'
    printf "%s\n" $"options:"
    printf "%s\n" $" pacman extension - can be used with the -S, -Ss, -Si, -Sw, -Su, -Sc, -Scc operations"
    printf "%s\n" $"   -a, --aur        only search, build, install or clean target(s) from the AUR"
    printf "%s\n" $"   -r, --repo       only search, build, install or clean target(s) from the repositories"
    printf "%s\n" $" general"
    printf "%s\n" $"   -e, --edit       edit target(s) PKGBUILD and view install script"
    printf "%s\n" $"   -q, --quiet      show less information for query and search"
    printf "%s\n" $"   --devel          consider AUR development packages upgrade"
    printf "%s\n" $"   --foreign        consider already installed foreign dependencies"
    printf "%s\n" $"   --ignore         ignore a package upgrade (can be used more than once)"
    printf "%s\n" $"   --needed         do not reinstall already up-to-date target(s)"
    printf "%s\n" $"   --noconfirm      do not prompt for any confirmation"
    printf "%s\n" $"   --noedit         do not prompt to edit files"
    printf "%s\n" $"   --rebuild        always rebuild package(s)"
    printf "%s\n" $"   --silent         silence output"
    exit "$E_OK"
}

#
# Main
#

# options
OPT_SHORT="DFQRSTUVacdefghiklmnopqrstuvwxy"
OPT_LONG=('help' 'database' 'files' 'query' 'remove' 'sync' 'deptest' 'upgrade')
OPT_LONG+=('asdeps' 'asexplicit' 'cascade' 'changelog' 'check' 'confirm' 'dbonly' 'debug' 'deps'
           'disable-download-timeout' 'downloadonly' 'explicit' 'file' 'foreign' 'groups' 'info'
           'list' 'machinereadable' 'native' 'needed' 'noconfirm' 'nodeps' 'noprogressbar' 'nosave'
           'noscriptlet' 'owns' 'print' 'recursive' 'refresh' 'regex' 'quiet' 'search' 'sysupgrade'
           'unneeded' 'unrequired' 'upgrades' 'verbose')
OPT_LONG+=('arch:' 'assume-installed:' 'cachedir:' 'color:' 'config:' 'dbpath:' 'gpgdir:' 'hookdir:'
           'ignore:' 'ignoregroup:' 'logfile:' 'overwrite:' 'print-format:' 'root:' 'sysroot:')
OPT_LONG_AUR=('aur' 'by:' 'devel' 'edit' 'literal' 'noedit' 'rebuild' 'repo' 'rsort:' 'searchby:'
              'silent' 'sort:' 'update' 'version')
parseopts "${OPT_SHORT}" "${OPT_LONG[@]}" "${OPT_LONG_AUR[@]}" -- "$@" || exit "$E_INVALID_OPTION"
set -- "${OPTRET[@]}"

while true; do
    [[ "$1" = -[cdf-qs-zDFQRSTUV] ]] && PACMAN_ARGS+=("$1")
    for i in "${OPT_LONG[@]}"; do
        [[ "$1" = "--$i" ]] && PACMAN_OPTS+=("$1")
        [[ "$1": = "--$i" ]] && PACMAN_OPTS+=("$1=$2")
    done
    case "$1" in
        -S|--sync) PACS=1; INSTALLPKG=1; OPERATION=sync; ((++PAC));;
        -Q|--query) PACQ=1; ((++PAC));;
        -s|--search) SEARCH=1;;
        -i|--info) INFO=1;;
        -e|--edit) PACE=1;;
        -u|--upgrades|--sysupgrade) UPGRADE=1;;
        -q|--quiet) QUIET=1; AURACLE_OPTS+=("$1");;
        -c|--clean) CLEANCACHE=1 && ((++CCOUNT));;
        -n|--native) NATIVE=1;;
        -r|--repo) REPO=1;;
        -a|--aur) AUR=1;;
        --ignore) ignoredpkgs+=("$2"); shift;;
        --color) COLOR="$2"; shift;;
        --literal) AURACLE_OPTS+=("$1");;
        --*(search)by) AURACLE_OPTS+=("--searchby=$2"); shift;;
        --sort) sortorder="ascending"; sortby="$2"; shift;;
        --rsort) sortorder="descending"; sortby="$2"; shift;;
        -d|--nodeps) NODEPS=1; MAKEPKG_OPTS+=("$1"); ((++DCOUNT));;
        --assume-installed) assumeinstalled+=("$2"); shift;;
        -[DFRTUV--@(database|files|remove|deptest|upgrade)) ((++PAC));;
        --@(asdeps|asexplicit|devel|needed|noconfirm|noedit|rebuild)) i="${1#--}"; declare "${i^^}"=1; unset i;;
        -[glp]|--@(groups|list|print)) NOOP=1;;
        -w|--downloadonly) DOWNLOADONLY=1;;
        --silent) silent=true; PACMAN_ARGS+=("-q"); AURACLE_OPTS+=("-q") MAKEPKG_OPTS+=("-L");;
        -y|--refresh) REFRESH=1;;
        -h|--help) HELP=1;;
        --version) OPERATION=version; ((++PAC));;
        -v) VER=1;;
        --) shift; break;;
    esac
    shift
done

# help or version
[[ "$OPERATION" = version ]] || (( PAC == 0 && VER )) && printf '%s\n' "pacaur $pacaur_version" && exit "$E_OK"
(( PAC == 0 && HELP )) && Usage

# sorting
case "$sortorder" in
    ascending)  AURACLE_OPTS+=("--sort=$sortby");;
    descending) AURACLE_OPTS+=("--rsort=$sortby");;
esac

# packages
pkgs=("$@")

# Color
if [[ ! "$COLOR" ]]; then
    [[ ! "$(pacman-conf Color)" || "$OPERATION" = upgrades ]] || (( QUIET && SEARCH )) &&
        COLOR=never || COLOR=auto
fi
PACMAN_OPTS+=("--color=$COLOR") && AURACLE_OPTS+=("--color=$COLOR")
if [[ ! "$COLOR" = never ]]; then
    ALL_OFF="\e[0m"; RED="\e[1;31m"; GREEN="\e[1;32m"; YELLOW="\e[1;33m"
    BLUE="\e[1;34m"; MAGENTA="\e[1;35m"; WHITE="\e[1;39m"
else
    ALL_OFF='' RED='' GREEN='' YELLOW='' BLUE='' MAGENTA='' WHITE='' MAKEPKG_OPTS+=('-m')
fi

# sanity check
(( AUR )) && REFRESH=0
(( PAC == 0 && PACE )) && OPERATION=edit
(( PACQ && PACE )) && PACMAN_OPTS+=('-e')
(( PACQ && UPGRADE )) && OPERATION=upgrades
(( PACQ && NATIVE )) && REPO=1
(( PACS && UPGRADE )) && INSTALLPKG=1
(( PACS && DOWNLOADONLY )) && INSTALLPKG=0
(( PACS && NOOP )) && OPERATION=''
(( PACS && CLEANCACHE )) && SEARCH=0 INFO=0 UPGRADE=0
(( PAC > 1 )) && Note "e" $"only one operation may be used at a time" "$E_FAIL"
[[ "$OPERATION" = sync ]] && (( ! SEARCH && ! INFO && ! CLEANCACHE && EUID == 0 )) &&
    Note "e" $"you cannot perform this operation as root" "$E_ROOT"
(( PACS && SEARCH && INFO )) &&
    Note "e" $"invalid option: '--info' and '--search' may not be used together" "$E_INVALID_OPTION"
[[ "$(command -v "${editor%% *}")" ]] ||
    Note "e" $"${WHITE}\$VISUAL${ALL_OFF} and ${WHITE}\$EDITOR${ALL_OFF} environment variables not set or defined ${WHITE}editor${ALL_OFF} not found" "$E_MISSING_FILE"
[[ "$PACMAN" = "${0##*/}" ]] &&
    Note "e" $"you cannot use ${WHITE}pacaur${ALL_OFF} as PACMAN environment variable" "$E_FAIL"
[[ -w "$clonedir" ]] ||
    Note "e" $"${WHITE}$clonedir${ALL_OFF} does not have write permission" "$E_FS_PERMISSIONS"
(( ! REFRESH && ! UPGRADE && ! CLEANCACHE )) && [[ "${pkgs[*]}" && "$OPERATION" =~ (sync|edit) ]] &&
    Note "e" $"no targets specified (use -h for help)" "$E_FAIL"
    (( ! HELP )) && [[ ! "${pkgs[*]}" && " ${PACMAN_ARGS[*]} " =~ ' '-[RU]' ' ]] &&
    Note "e" $"no targets specified (use -h for help)" "$E_FAIL"
(( AUR && REPO )) && AUR=0 && REPO=0 &&
    Note "w" $"invalid option: '-r/--repo' and '-a/--aur' may not be used together, disabling both"

# operations
case "$OPERATION" in
    edit) # edit (-e) handling
        GetPkgbase "${pkgs[@]}"
        EditPkgs "${pkgsbase[@]}"
        exit;;
    sync)
        # search (-Ss, -s) handling
        if (( SEARCH )); then
            if (( ! AUR )); then
                if (( REFRESH )); then
                    sudo "$PACMAN" ${PACMAN_ARGS[@]} ${PACMAN_OPTS[@]} -- ${pkgs[@]}
                else
                    "$PACMAN" ${PACMAN_ARGS[@]} ${PACMAN_OPTS[@]} -- ${pkgs[@]}
                fi
                exitrepo=$?
            fi
            if (( ! REPO )); then
                auracle search ${AURACLE_OPTS[@]} -- ${pkgs[@]}; exitaur="$?"
            fi
            # exit code
            [[ "$exitrepo" = 0 || "$exitaur" = 0 ]] && exit "$E_OK" || exit "$E_FAIL"
        # info (-Si, -i) handling
        elif (( INFO )); then
            if [[ ! "${pkgs[*]}" ]]; then
                "$PACMAN" ${PACMAN_ARGS[@]} ${PACMAN_OPTS[@]}
            else
                ClassifyPkgs "${pkgs[@]}"
            fi
            if [[ "${repopkgs[*]}" ]]; then
                (( REFRESH )) && sudo "$PACMAN" ${PACMAN_ARGS[@]} ${PACMAN_OPTS[@]} ${repopkgs[@]}
                (( ! REFRESH )) && "$PACMAN" ${PACMAN_ARGS[@]} ${PACMAN_OPTS[@]} ${repopkgs[@]}
            fi
            if [[ "${aurpkgs[*]}" ]]; then
                (( REFRESH && ! "${#repopkgs[*]}" )) && sudo "$PACMAN" -Sy ${PACMAN_OPTS[@]}
                (( ! AUR )) &&
                    Note "i" $"Package(s) ${WHITE}${aurpkgs[*]}${ALL_OFF} not found in repositories, trying ${MAGENTA}AUR${ALL_OFF}..."
                auracle info "${AURACLE_OPTS[@]}" -- "${aurpkgs[@]}"
            fi
        # clean (-Sc) handling
        elif (( CLEANCACHE )); then
            (( ! AUR )) && sudo "$PACMAN" ${PACMAN_ARGS[@]} ${PACMAN_OPTS[@]} ${repopkgs[@]}
            (( ! REPO )) && CleanCache "${pkgs[@]}"
        # sysupgrade (-Su, -u) handling
        elif (( UPGRADE )); then
            [[ "${pkgs[*]}" ]] && ClassifyPkgs "${pkgs[@]}"
            if (( ! AUR )); then
                sudo "$PACMAN" ${PACMAN_ARGS[@]} ${PACMAN_OPTS[@]} ${repopkgs[@]}
                (( $? > 0 && REPO )) && exit "$E_FAIL"
            fi
            if [[ "${aurpkgs[*]}" ]] && (( ! AUR )); then
                Note "i" $"Package(s) ${WHITE}${aurpkgs[*]}${ALL_OFF} not found in repositories, trying ${MAGENTA}AUR${ALL_OFF}..."
            fi
            (( ! REPO )) && Core
        # sync (-S, -y), downloadonly (-Sw, -m), refresh (-Sy)
        else
            if [[ ! "${pkgs[*]}" ]]; then
                sudo "$PACMAN" ${PACMAN_ARGS[@]} ${PACMAN_OPTS[@]}
            else
                ClassifyPkgs "${pkgs[@]}"
            fi
            [[ "${repopkgs[*]}" ]] && sudo "$PACMAN" ${PACMAN_ARGS[@]} ${PACMAN_OPTS[@]} ${repopkgs[@]}
            if [[ "${aurpkgs[*]}" ]]; then
                (( REFRESH && ! "${#repopkgs[*]}" )) && sudo "$PACMAN" -Sy ${PACMAN_OPTS[@]}
                (( ! AUR )) && Note "i" $"Package(s) ${WHITE}${aurpkgs[*]}${ALL_OFF} not found in repositories, trying ${MAGENTA}AUR${ALL_OFF}..."
                Core
            fi
        fi
        exit;;
    upgrades) # upgrades (-Qu) handling
        (( AUR )) || "$PACMAN" ${PACMAN_ARGS[@]} ${PACMAN_OPTS[@]} -- ${pkgs[@]}; exitrepo=$?
        if (( ! REPO )); then
            if [[ ! "${pkgs[*]}" ]]; then
                auracle sync ${AURACLE_OPTS[@]} $("$PACMAN" -qm ${PACMAN_ARGS[@]//-u} ${PACMAN_OPTS[@]//--upgrades})
            else
                auracle sync ${AURACLE_OPTS[@]} -- ${pkgs[@]}
            fi
            exitaur=$?
        fi
        [[ "$exitrepo" = 0 || "$exitaur" = 0 ]] && exit "$E_OK" || exit "$E_FAIL";;
    *) if [[ " ${PACMAN_ARGS[*]} " =~ ' -F ' ]] && (( REFRESH )); then
            sudo "$PACMAN" ${PACMAN_ARGS[@]} ${PACMAN_OPTS[@]} -- ${pkgs[@]}
        elif [[ ! "${pkgs[*]}" ]] ||
            [[ " ${PACMAN_ARGS[*]} " =~ ' '-[DFQTglp]' ' ]] && (( ! ASDEPS && ! ASEXPLICIT )); then
            "$PACMAN" ${PACMAN_ARGS[@]} ${PACMAN_OPTS[@]} -- ${pkgs[@]}
        else
            sudo "$PACMAN" ${PACMAN_ARGS[@]} ${PACMAN_OPTS[@]} -- ${pkgs[@]}
        fi
        exit;; # others operations handling
esac

# vim:set ts=4 sw=4 et:
